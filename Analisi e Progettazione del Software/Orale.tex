\documentclass[12pt]{article}
\usepackage[italian]{babel}

\title{Orale APS}
\author{Giuseppe Facchi}

\begin{document}

\maketitle
\tableofcontents

\newpage

\section{Processi per lo sviluppo software}
\subsection{Introduzione}
Un processo per lo sviluppo software definisce un approccio per la costruzione, il rilascio e la manutenzione del software. Esempi:
\begin{itemize}
    \item \textbf{Processo a cascata}
    \item \textbf{UP}
    \item Scrum
    \item Spirale
\end{itemize}
\subsection{Processo a cascata}
Il processo software con ciclo di vita \textbf{a cascata} è basato su uno svolgimento \textbf{sequenziale} delle diverse attività.\\
Questo processo è \textbf{molto soggetto a fallimenti}, perché più si fa grande il software più è difficile implementare nuove features.

\subsection{Sviluppo iterativo ed evolutivo}
In questo approccio lo sviluppo è organizzato in una serie di mini-progetti brevi, di lunghezza fissa chiamati \textbf{iterazioni}. Il risultato di ciascuna iterazione è un \textbf{sistema eseguibile, testato e integrato}.\\
\textit{Può essere chiamato anche sviluppo iterativo e incrementale o sviluppo iterativo ed evolutivo}.
\paragraph{Vantaggi}
\begin{itemize}
    \item \textbf{Minore probabilità di fallimento}
    \item Riduzione \textbf{precoce} dei rischi maggiori
    \item \textbf{Progresso visibile} fin dall'inizio
    \item \textbf{Feedback precoce}, con coinvolgimento dell'utente
\end{itemize}
\paragraph{Timeboxing:} Le iterazioni hanno una \textbf{lunghezza fissata}
\subsubsection{Pianificazione iterativa, guidata dal rischio e dal cliente}
In ciascuna \textbf{iterazione} viene stabilito il piano di lavoro dettagliato per una sola iterazione. In \textit{UP} viene effettuata alla \textbf{fine} di ciascuna iterazione, per decidere il piano dell'iterazione successiva.
\subsection{UP}
\textbf{Unified Process} è un processo \textbf{iterativo} per la costruzione di sistemi orientati agli oggetti. In particolare viene ampiamente adottato \textbf{RUP (Rational Unified Process)}, un suo raffinamento.
\begin{itemize}
    \item Processo \textbf{iterativo}
    \item Le pratiche di UP forniscono un esempio di struttura rispetto a come \textbf{eseguire} e dunque come spiegare l'\textbf{OOA/D} \textit{(Object-Oriented Analysis/Design)}
    \item UP è \textbf{flessibile} e può essere applicato usando un \textbf{approccio leggero e agile} come ad esempio \textbf{Scrum}
\end{itemize}
\subsubsection{Le fasi di UP}
\begin{itemize}
    \item \textbf{Ideazione:} \textit{NON è la previsione dei requisiti del modello a cascata, ma una fase di fattibilità}
    \item \textbf{Elaborazione}
    \item \textbf{Costruzione}
    \item \textbf{Transizione}
\end{itemize}
\subsubsection{Le discipline di UP}
Una \textbf{disciplina} è un insieme di attività e dei relativi elaborati di una determinata area. In UP un elaborato è un qualsiasi prodotto di lavoro. Ci sono diverse discipline in UP:
\begin{itemize}
    \item \textbf{Modellazione del business}: Modello di dominio
    \item \textbf{Requisiti}: Modello dei Casi d'uso per definire requisiti funzionali e non funzionali
    \item \textbf{Progettazione}: Modello di Progetto
\end{itemize}
\subsection{Agile}
\textit{Non è possibile dare una definizione precisa di metodo agile perché le pratiche adottate variano notevolmente da metodo a metodo}. \\Una pratica di base è quella che prevede \textbf{iterazioni brevi}, con raffinamenti evolutivi dei piani, dei requisiti e del progetto. \\Lo \textbf{scopo della modellazione e dei modelli} è di \textbf{agevolare la comprensione e la comunicazione, NON di documentare}.
\subsection{Fase di Ideazione}
Lo scopo della fase di ideazione è stabilire una visione iniziale comune per gli obiettivi del progetto.
\begin{itemize}
    \item Non si definiscono tutti i requisiti nella fase di ideazione
    \item La maggior parte del'analisi dei requisiti avviene durante la fase di elaborazione
    \item Modello dei Casi d'Uso
\end{itemize}
\newpage
\section{Requisiti evolutivi}
Un sistema deve fornire un certo numero di funzionalità, relative alla gestione di alcune tipologie di informazione e al possesso di determinate qualità (sicurezza e prestazioni). Un requisito è una capacità o una condizione a cui il sistema deve essere conforme. 
\paragraph{Requisiti funzionali} Descrivono il comportamento del sistema in termini di funzionalità fornite ai suoi utenti. Possono essere espressi in forma di casi d'uso.
\paragraph{Requisiti non funzionali} Non riguardano le specifiche funzioni del sistema, ma sono relativi a proprietà del sistema, ad esempio sicurezza, prestazioni, scalabilità, ecc.
\subsection{Modello dei Casi d'uso}
In generale i casi d'uso sono storie scritte, testuali, di qualche attore che usa un sistema per raggiungere degli obiettivi. I casi d'uso non sono diagrammi, bensì testo.
\paragraph{Attore} Qualcosa o qualcuno dotato di comportamento, come una persona o un'organizzazione o un sistema informatico.
\paragraph{Scenario (istanza di caso d'uso)} E' una sequenza specifica di azioni e interazioni tra il sistema e alcuni attori.
\\[12pt]
\noindent Un caso d'uso è quindi una collezione di scenari correlati, sia di successo che di fallimento. I casi d'uso sono Requisiti Funzionali.
\subsubsection{Attori}
\begin{itemize}
    \item \textbf{Attore Primario}: Utilizza direttamente ii servizi del SuD (system under discussion) affinché vengano raggiunti gli obiettivi utente.
    \item \textbf{Attore Finale}: Vuole che il SuD sia utilizzato affinché vengano raggiunti dei suoi obiettivi. Spesso attore primario e finale coincidono (es. Cliente commercio elettronico).
    \item \textbf{Attore di Supporto}: Offre un servizio al SuD (es. Sistema di autorizzazione al pagamento).
    \item \textbf{Attore fuori scena}: Non è un attore primario, finale, di supporto (es. Governo). 
\end{itemize}
\subsubsection{Notazione: tre formati per i casi d'uso}
\begin{itemize}
    \item Formato breve
    \item Formato informale
    \item Formato dettagliato
\end{itemize}
\subsubsection{Come trovare i casi d'uso}
\begin{enumerate}
    \item Scegliere i confini del sistema
    \item Identificare gli attori primari
    \item Identificare gli obiettivi di ciascun attore primario
    \item Definire i casi d'uso che soddisfino gli obiettivi utente
\end{enumerate}
\subsubsection{Verificare l'utilità dei casi d'uso}
\paragraph{Test del capo} Il capo pone una domanda per cui ci sarà una risposta, se la risposta non soddisfa il capo il caso d'uso non è mirato a ottenere i risultati il cui valore sia misurabile. Non è però sempre vero (es. Autenticazione utente, concetto semplice ma difficilmente implementabile)
\paragraph{Test EBP (Elementary Business Process)} Simile al test del capo. Un processo di business elementare è un'attività svolta in risposta a un evento di business, che aggiunge valore e lascia i dati in uno stato consistente.
\paragraph{Test della dimensione} Un caso d'uso deve essere costituito da più passi e corrisponde a 3 o più pagine nel formato dettagliato.
\subparagraph{Esempi}
\begin{itemize}
    \item \textit{Negoziare un contratto con un fornitore}: Troppo ampio per essere un EBP
    \item \textit{Gestire una restituzione}: Passa il test del capo, è un EBP, le dimensioni vanno bene
    \item \textit{Effettuare il login}: Non passa il test del capo
    \item \textit{Spostare una pedina}: Non passa il test della dimensione
\end{itemize} 
\newpage
\section{Modellazione di dominio}
Rappresentazione visuale di classi concettuali o di oggetti del mondo reale e delle relazioni tra di essi.
\subsection{Diagramma delle classi (modello di dominio)}
Applicando la notazione UML un modello di dominio può essere rappresentato da uno o più diagramma delle classi. Prevede:
\begin{itemize}
    \item \textbf{Classi concettuali}: rapprentano cose o concetti del dominio di interesse
    \item \textbf{Associazioni tra classi}: rappresentano relazioni tra oggetti di due classi
    \item \textbf{Attributi di classi concettuali}: rappresentano proprietà elementari degli oggetti di una classe
\end{itemize}
\subparagraph{Aggregazione e composizione}
\begin{itemize}
    \item \textbf{Aggregazione}: Tipo di associazione intero-parte (es. macchina-ruote)
    \item \textbf{Composizione}: Tipo di forte associazione intero-parte
    \begin{itemize}
        \item Ciascuna istanza della parte appartiene a una sola istanza dell'intero alla volta
        \item Ciascuna parte deve sempre appartenere ad un intero
        \item La vita delle parti è limitata dall'intero: le parti possono essere create dopo l'intero, ma non prima e possono essere distrutte prima dell'intero, ma non dopo
    \end{itemize}
\end{itemize}
\subsection{Diagramma degli oggetti}
Mostra un insieme di oggetti con i loro attributi e le loro relazioni in un dato momento.

\section{Diagrammi di interazione (parte di modello dei casi d'uso)}
\begin{itemize}
    \item \textbf{Illustrazione dei partecipanti con le Lifelines}: rappresentano un'istanza di una classe
    \item \textbf{Definizione dei messaggi scambiati tra gli oggetti}
\end{itemize}
\subsection{Operazioni di sistema e diagrammi di sequenza di sistema}
Un diagramma di sequenza di sistema è un elaborato che illustra, per un particolare caso d'uso, eventi di input e di output relativi ai sistemi in discussione con un formato "a steccato" in cui gli oggetti che partecipano all'interazione sono mostrati in alto, uno a fianco dell'altro. Esso costituisce un input per i contratti delle operazioni e soprattutto per la progettazione degli oggetti.
\\I casi d'uso descrivono il modo in cui gli attori esterni interagiscono con il sistema software che interessa creare. Durante questa interazione, un attore genera \textbf{eventi di sistema}, che costituiscono un input per il sistema, di solito per richiedere l'esecuzione di alcune \textbf{operazioni di sistema}, che sono operazioni che il sistema deve definire proprio per gestire tali eventi.
\subsubsection{Contratti}
Le sezioni di un contratto sono:
\begin{itemize}
    \item \textbf{Operazione}: Nome e parametri dell'operazione
    \item \textbf{Riferimenti}: Casi d'uso in cui può verificarsi questa operazione
    \item \textbf{Pre-condizioni}: Ipotesi sullo stato del sistema prima dell'esecuzione
    \item \textbf{Post-condizioni}: Descrive i cambiamenti di stato degli oggetti nel modello di dominio dopo il completamento dell'operazione
\end{itemize}
\subsection{Diagrammi di comunicazione}
Mostrano le interazioni tra gli oggetti in un formato a grafo o a rete. in cui gli oggetti possono essere posizionati dovunque nel diagramma.

\subsection{Pro/Contro diagrammi Sequenza/Comunicazione}
I diagrammi di sequenza sono strumenti più potenti perché:
\begin{itemize}
    \item UML è più incentrato sui diagrammi di sequenza
    \item Più facile vedere la sequenza "call-flow" poiché il tempo trascorre dall'alto verso il basso
\end{itemize}
I diagrammi di comunicazione sono strumenti più versatili perché:
\begin{itemize}
    \item Effettuare modifiche è più semplice senza modificare l'intero call-flow
    \item Sono più comodi da disegnare
\end{itemize}
\section{Diagramma delle classi di progetto}
\subsection{Generalizzazione}
Una generalizzazione è una \textbf{relazione tassonomica} tra un classificatore più generale e un classificatore più specifico. 
\\\textbf{NON equivale} all'ereditarietà nel \textbf{modello di dominio}
\\\textbf{Equivale} all'ereditarietà nel \textbf{modello di progettazione}, infatti qui la generalizzazione implica l'ereditarietà

\subsection{Aggregazione e composizione}
\begin{itemize}
    \item \textbf{Aggregazione}: Tipo di associazione intero-parte (es. macchina-ruote)
    \item \textbf{Composizione}: Tipo di forte associazione intero-parte
    \begin{itemize}
        \item Ciascuna istanza della parte appartiene a una sola istanza dell'intero alla volta
        \item Ciascuna parte deve sempre appartenere ad un intero
        \item La vita delle parti è limitata dall'intero: le parti possono essere create dopo l'intero, ma non prima e possono essere distrutte prima dell'intero, ma non dopo
    \end{itemize}
\end{itemize}
\newpage
\section{Diagrammi di attività}
Alcuni flussi di interazioni che devono essere supportati dal sistema possono essere \textbf{particolarmente elaborati e difficili da rappresentare con un caso d’uso}: è possibile utilizzare i diagrammi di attività in questo caso. \\[12pt]Nei diagrammi delle attività vengono rappresentati \textbf{azioni, flusso delle azioni, partecipanti, dati e flusso dei dati per diversi casi d’uso}. \\[12pt]Consentono di modellare un processo come un’attività costituita da un \textbf{insieme di nodi connessi da archi}. \\[12pt]Non è sempre chiaro quale parte dell’organizzazione esegue le varie attività, quindi i diagrammi possono essere in partizioni che mostrano le azioni intraprese da una singola organizzazione e classe.
\newpage
\section{Diagrammi di stato}
Le macchine a stati possono essere utilizzate per \textbf{modellare il comportamento dinamico di classificatori} quali classi, casi d’uso, sottoinsiemi e interi sistemi. \\[12pt]Le macchine a stati esistono nel contesto di un particolare classificatore che risponde a eventi esterni, ha un \textbf{ciclo di vita definito} che può essere modellato come una successione di stati, transizioni ed eventi, e \textbf{può avere un comportamento corrente che dipende dai comportamenti precedenti}. \\[12pt]Solitamente vengono utilizzate per modellare il comportamento dinamico di classi. \\[12pt]Ogni macchina a stati ha uno \textbf{stato iniziale} che indica il primo stato della sequenza, e uno \textbf{stato finale} che termina la sequenza a meno che non esista un ciclo perpetuo di stati.
\\[12pt]Uno \textbf{stato è una condizione o situazione della vita di un oggetto durante la quale tale oggetto soddisfa una condizione, esegue un’attività, o aspetta un evento}. 
\newpage
\section{RDD}
RDD (Responsibility-Driven Deployment) è un modello di progettazione oggetti basata su:
\begin{itemize}
    \item Responsabilità, astrazione di ciò che si deve saper fare e responsabilità degli oggetti
    \item Ruoli, obiettivi e capacità che un oggetto o una classe ha di partecipare a una relazione con un altro oggetto
    \item Collaborazione tra oggetti per raggiungere un obiettivo.
\end{itemize}
Ci sono due tipologie di responsabilità, quella di fare e quella di conoscere.La granularità (fine o grossa) rappresenta la specificità delle azioni in base al loro scopo.Le responsabilità vengono assegnate durante la modellazione o durante la codifica. In contesto UML le responsabilità sono individuate mentre si creano i modelli statici e dinamici del sistema.I pattern sono principi generali e soluzioni idiomatiche per la creazione di software, codificati in un formato che descrive il problema e la soluzione
\section{GRASP: Progettazione di oggetti con responsabilità}
I GRASP definiscono nove principi di progettazione OO di base o blocchi di costruzione elementari della progettazione. GRASP è l'acronimo di General Responsibility Assignment Software Patterns, ovvero di "Pattern generali per l'assegnazione di responsabilità nel software". 
\paragraph{Creator} chi crea un oggetto particolare. In generale, i contenitori creano le cose contenute. La classe padre può contenere o aggregare con una composizione della classe figlia, utilizzarla strettamente o possederne i dati per l’inizializzazione
\subparagraph{Vantaggi}
\begin{itemize}
    \item Creator fornisce un accoppiamento basso, il che implica minori dipendenze di manutenzione e maggiori opportunità di riuso
\end{itemize}
\paragraph{Information expert} è la classe che ha le informazioni necessarie per adempiere ad alcune responsabilità (classi rilevanti nel modello di progettazione,altrimenti in quello di dominio o analisi). Le classi che possiedono le informazioni necessarie per soddisfare una richiesta hanno responsabilità. (es. Per calcolare il totale di una vendita vengono chiamate in causa più classi)
\subparagraph{Vantaggi}
\begin{itemize}
    \item L'incapsulamento delle informazioni viene mantenuto, poiché gli oggetti usano le proprie informazioni per adempiere ai propri compiti
\end{itemize}
\paragraph{Low Coupling} dipendenza bassa, impatto dei cambiamenti basso e riuso elevato. L’accoppiamento indica quanto fortemente un elemento è connesso ad altri elementi, ha conoscenza di altri elementi e ne dipende.
\subparagraph{Vantaggi}
\begin{itemize}
    \item Una classe o componente con un accoppiamento basso non è influenzata dai cambiamenti nelle altre classi e componenti
    \item Semplice da capire separatamente dalle altre classi e componenti
    \item Conveniente da riusare
\end{itemize}
\paragraph{High Coesion} indica quanto siano correlate e concentrate le responsabilità di un elemento. Le classi con coesione bassa sono difficili da comprendere, riusare e mantenere.Una classe con coesione alta ha un numero di metodi relativamente basso, con funzionalità altamente correlate e non fa troppo lavoro
\subparagraph{Vantaggi}
\begin{itemize}
    \item Modularità del software
    \item Riuso delle classi
    \item Classi facili da mantenere
\end{itemize}
\newpage
\paragraph{Controller} il primo oggetto oltre lo strato di UI che è responsabile di ricevere e gestire un messaggio di un’operazione di sistema. L’oggetto deve rappresentare il sistema oppure uno scenario di un caso d’uso, in modo da verificare la sequenza delle operazioni e lo stato corrente delle attività. La logica è svincolata dall’UI e si possono usare interfacce diverse.
\subparagraph{Vantaggi}
\begin{itemize}
    \item Maggiore potenziale di riuso e interfacce inseribili
    \item Opportunità di ragionare sullo stato del caso d'uso (gestire le sessioni)
\end{itemize}
\newpage
\section{Design Patterns}
\paragraph{Pattern}
\begin{itemize}
    \item Descrive un problema specifico che ricorre più volte
    \item Descrive il nucleo della soluzione a quel problema in modo da poter utilizzare tale soluzione molte voltesenza mai applicarla nello stesso modo
\end{itemize}
\paragraph{Design Pattern}
\begin{itemize}
    \item Regola tripartita
    \item Esprime una relazione tra contesto problema e soluzione
    \item Nomina, astrae identifica aspetti chiave di una struttura di design comune
    \item Identifica classi e istanze che partecipano, ruoli, modalità dicollaborazione e distribuzione delle responsabilità
\end{itemize}

Sono divisi in 3 categorie:
\begin{itemize}
    \item \textbf{Creational}: Pattern che forniscono un'astrazione del processo di instanziazione degli oggetti. Permettono di rendere un sistema indipendente da come gli oggetti sono creati/rappresentati/composti al suo interno
    \item \textbf{Structural}: Dedicati alla composizione di classi e oggetti per formare strutture complesse. È possibile creare delle classi che ereditano da più classi per consentire di utilizzare proprietà di più superclassi
    indipendenti. Sono particolarmente utili per fare in modo che librerie di classi sviluppate indipendentemente possano operare insieme
    \item \textbf{Behavioral}: Sono dedicati all'assegnamento di responsabilità tra gli oggetti e alla creazione di algoritmi. L'utilizzo di questi pattern permette di dedicarsi principalmente alle connessioni tra oggetti, tralasciando la gestione dei flussi di controllo
\end{itemize}
\newpage
\subsection{Alcuni Design patterns}
\subsubsection{Adapter}
\subparagraph{Problema} Come gestire interfacce incompatibili, o fornire un'interfaccia stabile a componenti simili ma con interfacce diverse?
\subparagraph{Soluzione} Converti l'interfaccia di un componente in un'altra interfaccia, attraverso un oggetto \textbf{adapter} intermedio.
\subsubsection{Factory}
\subparagraph{Problema} Chi deve essere responsabile della creazione di oggetti quando ci sono delle considerazioni speciali, come una logica di creazione complessa, quando si desidera separare la responsabilità di creazione per una coesione migliore, e così via?
\subparagraph{Soluzione} Crea un oggetto \textbf{pure fabrication} chiamato \textbf{factory} che ne gestisce la creazione
\subsubsection{Singleton}
\subparagraph{Problema} E' consentita esattamente una sola istanza di una classe, ovvero un "singleton". Gli altri oggetti hanno bisogno di un punto di accesso globale e singolo a questo oggetto.
\subparagraph{Soluzione} Definisci un metodo statico della classe che restituisce l'oggetto singleton
\subsubsection{Strategy}
\subparagraph{Problema} Come progettare per gestire un insieme di algoritmi o politiche variabili ma correlati? Come progettare per consentire di modificare questi algoritmi o politiche?
\subparagraph{Soluzione} Definisci ciascun algoritmo/politica/strategia in una classe separata, con un'interfaccia comune 
\subsubsection{Composite}
\subparagraph{Problema} Come trattare un gruppo o una struttura composta di oggetti polimorficamente dello stesso tipo nello stesso modo di un oggetto non composto?
\subparagraph{Soluzione} Definisci le classi per gli oggetti composti e atomici in modo che implementino la stessa interfaccia
\subsubsection{Façade}
\subparagraph{Problema} E' richiesta un'interfaccia comune e unificata per un insieme disparato di implementazioni o interfacce, come per definire un sottosistema.
\subparagraph{Soluzione} Definisci un punto di contatto singolo con il sottosistema (un oggetto \textbf{façade}) che copre il sottosistema. Questo oggetto presenta un'interfaccia singola e unificata.
\subsubsection{Observer}
\subparagraph{Problema} Diversi tipi di oggetti \textbf{subscriber} sono interessati ai cambiamenti di stato o agli eventi di un oggetto \textbf{publisher}
\subparagraph{Soluzione} Definisci un'interfaccia \textbf{subscriber} o \textbf{listener}
\end{document}